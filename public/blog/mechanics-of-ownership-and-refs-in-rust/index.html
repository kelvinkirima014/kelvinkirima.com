<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>The Mechanics of Ownership, References, and Dereferences in Rust</title><meta content="The Mechanics of Ownership, References, and Dereferences in Rust" name=title><meta content=website property=og:type><meta content=https://kelvinkirima.com/blog/mechanics-of-ownership-and-refs-in-rust/ property=og:url><meta property=og:site_name><meta content="The Mechanics of Ownership, References, and Dereferences in Rust" property=og:title><meta content=https://kelvinkirima.com/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://kelvinkirima.com/blog/mechanics-of-ownership-and-refs-in-rust/ property=twitter:url><meta content="The Mechanics of Ownership, References, and Dereferences in Rust" property=twitter:title><meta content=https://kelvinkirima.com/favicon.ico property=twitter:image><link href=https://kelvinkirima.com/blog/mechanics-of-ownership-and-refs-in-rust/ rel=canonical><link rel="shortcut icon" href=https://kelvinkirima.com/favicon.ico type=image/x-icon><link href=https://kelvinkirima.com/css/style.css rel=stylesheet><script defer src=https://kelvinkirima.com/js/script.js></script><body><div class=wrapper><header><nav class=navBar><div class=profile-section><div class=home-link-container><a href=https://kelvinkirima.com> <img alt="Profile Picture" class=profile-pic src=https://kelvinkirima.com/logo.jpg> </a></div><div class=profile-info><span class=profile-text>Kirima</span><div class=nav-links><a href=/> Home </a><a href=/blog> Blog </a><a href=/faq> FAQ </a></div></div></div><div class=themeSwitch><button class="themeButton dark" onclick="setTheme('dark')" title="Dark mode"><svg class="icons icons__background"><use href=https://kelvinkirima.com/icons.svg#darkMode></use></svg></button><button class="themeButton light" onclick="setTheme('light')" title="Light mode"><svg class="icons icons__background"><use href=https://kelvinkirima.com/icons.svg#lightMode></use></svg></button></div></nav></header><main><div><a href=..>..</a>/<span class=metaData>mechanics-of-ownership-and-refs-in-rust</span></div><time datetime=2024-02-07>Published on: <span class=metaData>2024-02-07</span></time><h1>The Mechanics of Ownership, References, and Dereferences in Rust</h1><p>The design choices of a programming language has direct implications on how we write code. One such design choice is the concept of ownership and borrowing in the Rust programming language.<h2 id=ownership-references-and-immutability>Ownership, References and Immutability</h2><p>Stated simply, the concept of ownership deems that we can only have one owner of a value at a time, this value can be passed around severally for read-only operations by immutably borrowing or referencing, but we can only have one mutable borrow at a time.<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#b48ead>let mut</span><span> input = String::new();
</span><span>    input.</span><span style=color:#96b5b4>push_str</span><span>("</span><span style=color:#a3be8c>Hello World</span><span>");
</span><span>    println!("</span><span style=color:#a3be8c>input value is: </span><span style=color:#d08770>{:?}</span><span>", input);
</span><span>
</span><span>    </span><span style=color:#b48ead>let</span><span> take_ownership = input;
</span><span>    println!("</span><span style=color:#a3be8c>Taken ownership of value </span><span style=color:#d08770>{:?}</span><span>", take_ownership);
</span><span>
</span><span>    </span><span style=color:#b48ead>let</span><span> _illegal = input; </span><span style=color:#65737e>// throws an error -> use of moved value `input`
</span><span>}
</span></code></pre><p>The error message tells us we are trying to use a value which has already been moved to another memory location. When we create the variable <code>take_ownership</code>, we move the value in the <code>input</code>’s memory location to <code>take_ownership</code>, thus trying to allocate <code>input</code>’s value to another variable fails, because the value is no longer there. This is all by design, imagine if we were successful in having two variables own the value at the same time, and then have both variables mutate the value, we got ourselves a race condition, not good. Innit?<p>There’s a work-around to this that makes the error go away quickly; Instead of taking ownership, we just borrow the value<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> borrow_value = &input;
</span><span>println!("</span><span style=color:#a3be8c>...</span><span>");
</span><span>
</span><span style=color:#b48ead>let</span><span> another_borrow = &input
</span><span>println!("</span><span style=color:#a3be8c>...</span><span>");
</span></code></pre><p>The ampersand sign <code>&</code> denotes that we are taking a reference to the memory address the value is stored, but we’re not taking ownership of the value itself. Now we can have as many borrows as we want, but there’s a catch: We can only have one mutable reference at a time.<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> borrow_value = &</span><span style=color:#b48ead>mut</span><span> input; 
</span><span style=color:#b48ead>let</span><span> another_borrow = &</span><span style=color:#b48ead>mut</span><span> input;
</span></code></pre><p>If you tried writing code like the one above, your Rust <a href=https://microsoft.github.io/language-server-protocol/>LSP</a> should already be telling you that what you’re doing is unacceptable:<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span>error[</span><span style=color:#d08770>E0499</span><span>]: cannot borrow input as mutable more than once
</span></code></pre><p>But it’s possible to have another mutable borrow when the first borrow goes out of scope. The code below runs successfully because we create the variable <code>another_borrow</code> after <code>borrow_value</code> has already been used and it’s scope ended.<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> borrow_value = &</span><span style=color:#b48ead>mut</span><span> input;
</span><span>borrow_value.</span><span style=color:#96b5b4>push_str</span><span>("</span><span style=color:#a3be8c> Changers</span><span>");
</span><span>
</span><span style=color:#b48ead>let</span><span> another_borrow = &</span><span style=color:#b48ead>mut</span><span> input;
</span><span>println!("</span><span style=color:#a3be8c>another_borrow: </span><span style=color:#d08770>{:?}</span><span>", another_borrow);
</span></code></pre><p>The reference’s scope start from where it is introduced and continues through the last time that reference is used; when the reference goes out of scope, it’s borrow ends, and the value becomes available for borrowing again. When all references to the value are gone, Rust frees the memory where the value is located. These rules of ownership, borrowing and scope are what enables Rust to be able to allocate and free memory safely without a garbage collector, how practical!<h2 id=dereferencing>Dereferencing</h2><p>We’ve established that references do not hold any values by themselves, instead they point to the location in memory where the actual value is stored. Now, what if we want to modify the actual value the reference is pointing at? Take this simple example:<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>let mut</span><span> value = </span><span style=color:#d08770>20</span><span>;
</span><span style=color:#b48ead>let</span><span> ref_val = &</span><span style=color:#b48ead>mut</span><span> value;
</span></code></pre><p>Imagine that we want to change the <code>ref_value</code> to 30; to a new Rustacean, the first thought would be to do something like this:<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>   </span><span style=color:#b48ead>let mut</span><span> value = </span><span style=color:#d08770>20</span><span>;
</span><span>   </span><span style=color:#b48ead>let</span><span> ref_val = &</span><span style=color:#b48ead>mut</span><span> value;
</span><span>   ref_val = </span><span style=color:#d08770>30</span><span>;
</span><span>}
</span></code></pre><p>Trying to write the above code will have the compiler sympathizing with us:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>error[E0308]:</span><span> mismatched types
</span><span>  </span><span style=color:#bf616a>--</span><span>> src/main.rs:20:17
</span><span>   |
</span><span>|     </span><span style=color:#96b5b4>let</span><span> ref_value = &mut value;
</span><span>   |                     </span><span style=color:#bf616a>----------</span><span> expected due to this value
</span><span>|     </span><span style=color:#bf616a>ref_value</span><span> = 30;
</span><span>   |                 </span><span style=color:#bf616a>^^</span><span> expected &</span><span style=color:#bf616a>mut </span><span>{integer}, found integer
</span><span>   |
</span><span style=color:#bf616a>help:</span><span> consider dereferencing here to assign to the mutably borrowed value
</span><span>   |
</span><span> |     </span><span style=color:#bf616a>*ref_value</span><span> = 30;
</span><span>   |     </span><span style=color:#bf616a>+
</span></code></pre><p>I encourage you to take a minute and read the error message keenly. We get the error because <code>ref_value</code> holds the reference to the value, and not the value itself; in other terms, we are trying to assign to the reference, and not the value it points to, and Rust does not allow us to assign directly to the reference because this would mutate the actual value. So, what do we do? The compiler has already helped us with that. To assign the integer to the actual value, we need to <em>dereference</em><code> ref_value</code> and access the actual value behind it; we do this using the unary operator<code> *</code>.<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>let mut</span><span> value = </span><span style=color:#d08770>20</span><span>;
</span><span style=color:#b48ead>let</span><span> ref_val = &</span><span style=color:#b48ead>mut</span><span> value;
</span><span>*ref_val = </span><span style=color:#d08770>30</span><span>;
</span></code></pre><p>One question you may already have is why we didn’t have to do that with the <code>push_str</code> operations earlier:<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> borrow_value = &</span><span style=color:#b48ead>mut</span><span> input;
</span><span>borrow_value.</span><span style=color:#96b5b4>push_str</span><span>("</span><span style=color:#a3be8c> Changers</span><span>");
</span></code></pre><p>That’s because when we use the dot operator, the expression on the left-hand side of the dot is auto-referenced/auto-derefenced automatically. You can read more about the dot-operator <a href=https://doc.rust-lang.org/nomicon/dot-operator.html>here</a>.<h2 id=a-more-interesting-problem>A more Interesting Problem</h2><p>This article was inspired by a problem I encountered while working with the <a href=https://docs.rs/sqlx/latest/sqlx/index.html>sqlx</a> library; I wanted to have a database connection that I can reuse across multiple queries. Sqlx has a <code>begin</code> method that creates a database connection and immediately begins a new transaction, so what I need to do is figure out how to compose multi-statement transactions with it. My first attempt looks like so:<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span>async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>demo_txn</span><span>(</span><span style=color:#bf616a>db</span><span>: PgPool) -> Result<()> {
</span><span>	</span><span style=color:#b48ead>let</span><span> tx = db.</span><span style=color:#96b5b4>begin</span><span>().await.</span><span style=color:#96b5b4>map_errr</span><span>(|</span><span style=color:#bf616a>err</span><span>| {
</span><span>        error!("</span><span style=color:#a3be8c>error starting database transaction: {err}</span><span>");`
</span><span>    })?;
</span><span>    
</span><span>	</span><span style=color:#b48ead>let</span><span> row = sqlx::query("</span><span style=color:#a3be8c>...</span><span>").</span><span style=color:#96b5b4>fetch_one</span><span>(&</span><span style=color:#b48ead>mut</span><span> tx).await?;
</span><span>	
</span><span>	sqlx::query("</span><span style=color:#a3be8c>...</span><span>").</span><span style=color:#96b5b4>execute</span><span>(&</span><span style=color:#b48ead>mut</span><span> tx).await?;
</span><span>}
</span></code></pre><p>Above, I create a transaction, and then try to consume a mutable reference to the transaction in my queries; however, the code throws this error:<pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>error[E0277]:</span><span> the trait bound &</span><span style=color:#bf616a>mut</span><span> Transaction<'</span><span style=color:#a3be8c>_, Postgres>: sqlx::Executor
</span><span style=color:#a3be8c><</span><span>'_> is not satisfied
</span><span>   </span><span style=color:#bf616a>--</span><span>> src/routes/signup.rs:117:14
</span><span>    |
</span><span> |     </span><span style=color:#bf616a>.execute</span><span>(&</span><span style=color:#bf616a>mut</span><span> tx)
</span><span>    |      </span><span style=color:#bf616a>-------</span><span> ^^^^^^^ the trait sqlx::Executor<'</span><span style=color:#a3be8c>_> is not implemented 
</span><span style=color:#a3be8c>for &mut Transaction<</span><span>'_, Postgres>
</span><span>    |      |
</span><span>    |      </span><span style=color:#bf616a>required</span><span> by a bound introduced by this call
</span><span>    |
</span><span>    = </span><span style=color:#bf616a>help:</span><span> the following other types implement trait sqlx::Executor<'</span><span style=color:#a3be8c>c>:
</span><span style=color:#a3be8c>              <&</span><span>'c mut PgConnection as sqlx::Executor<'</span><span style=color:#a3be8c>c>>
</span><span style=color:#a3be8c>              <&</span><span>'c mut PgListener as sqlx::Executor<'</span><span style=color:#a3be8c>c>>
</span><span style=color:#a3be8c>              <&</span><span>'c mut AnyConnection as sqlx::Executor<'</span><span style=color:#a3be8c>c>>
</span><span style=color:#a3be8c>              <&Pool&LTDB> as sqlx::Executor<</span><span>'p>>
</span></code></pre><p>The error tells us that a trait we need is not implemented for our mutable reference to the <code>Transaction</code> type. These are one of those errors that have you scratching your head because the compiler has no more help to offer you, we are basically on our own now. The logical thing to do here is to dig into other people’s code and see if I can find out how others construct multi-statement transactions in sqlx. I came across a similar problem on Github, and the solution offered is to dereference the transaction:<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span>async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>demo_txn</span><span>(</span><span style=color:#bf616a>db</span><span>: PgPool) -> Result<()> {
</span><span>	</span><span style=color:#b48ead>let</span><span> tx = db.</span><span style=color:#96b5b4>begin</span><span>().await.</span><span style=color:#96b5b4>map_errr</span><span>(|</span><span style=color:#bf616a>err</span><span>| {
</span><span>        error!("</span><span style=color:#a3be8c>error starting database transaction: {err}</span><span>");
</span><span>    })?;
</span><span>    
</span><span>	</span><span style=color:#b48ead>let</span><span> row = sqlx::query("</span><span style=color:#a3be8c>...</span><span>").</span><span style=color:#96b5b4>fetch_one</span><span>(&</span><span style=color:#b48ead>mut </span><span>*tx).await?; </span><span style=color:#65737e>// notice the *
</span><span>	
</span><span>	sqlx::query("</span><span style=color:#a3be8c>...</span><span>").</span><span style=color:#96b5b4>execute</span><span>(&</span><span style=color:#b48ead>mut </span><span>*tx).await?; </span><span style=color:#65737e>//notice *
</span><span>}
</span></code></pre><p>And true enough, the errors go away; Interesting, let’s dig a little deeper to understand what’s going on. The <code>begin</code> method we call on the <code>db</code> looks like so:<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>pub</span><span> async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>begin</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> Result&LTTransaction<</span><span style=color:#b48ead>'static</span><span>, DB>, Error>
</span></code></pre><p>When we call <code>?</code> on the Result, we are left with the <code>Transaction</code> type:<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>pub struct </span><span>Transaction<</span><span style=color:#b48ead>'c</span><span>, DB>
</span><span>where
</span><span>    DB: Database,
</span><span>{ ...}
</span></code></pre><p>So, when we do <code>*tx</code>, we are asking for a mutable dereference to the <code>Transaction</code> because our methods are in a mutable expression context. Rust requires that types that want to be dereferenced implement the <a href=https://doc.rust-lang.org/std/ops/trait.Deref.html#>Deref</a> trait - for immutable dereference, or the <a href=https://doc.rust-lang.org/std/ops/trait.DerefMut.html>DerefMut</a> trait for mutable dereferences. The transaction type implements both of these traits, here’s the DerefMut implementation:<pre class=language-rust data-lang=rust style=background:#2b303b;color:#c0c5ce><code class=language-rust data-lang=rust><span style=color:#b48ead>impl</span><span><</span><span style=color:#b48ead>'c</span><span>, DB> DerefMut </span><span style=color:#b48ead>for </span><span>Transaction<</span><span style=color:#b48ead>'c</span><span>, DB>
</span><span style=color:#b48ead>where
</span><span>    DB: Database,
</span><span>{
</span><span>    #[</span><span style=color:#bf616a>inline</span><span>]
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>deref_mut</span><span>(&</span><span style=color:#b48ead>mut </span><span style=color:#bf616a>self</span><span>) -> &</span><span style=color:#b48ead>mut Self::</span><span>Target {
</span><span>        &</span><span style=color:#b48ead>mut </span><span style=color:#bf616a>self</span><span>.connection
</span><span>    }
</span><span>}
</span></code></pre><p>The <code>*</code> uses the above <code>DerefMut</code> implementation and yields a mutable <code>&LTDB as Database>::Connection</code> (the associated connection type for whichever DB we’re using). I’m using Postgres, so the deref gets us a mutable <a href=https://docs.rs/sqlx/latest/sqlx/struct.PgConnection.html>PgConnection</a> which implements the <code>sqlx::Executor</code> trait that was missing and thus causing the compilation error.<p>I understand this has been a long exposition, but an example like this goes to show how some of the errors we may encounter even with trait bound issues are directly tied to the concepts of ownership and references - and how deep they can go.<h2 id=finishing-up>Finishing Up</h2><p>Thanks for reading! I hope this article has helped shine some light on arguably some of the most important Rust concepts.<p class=tagsData></main><footer><hr><div class=footContainer><div class=footLeft>Copyright © 2024 <span aria-label="rocket emoji">🚀</span> Kirima</div><div class=footRight><p>Find me on</p><a href=https://github.com/kelvinkirima014 target=_blank> <img alt=GitHub class=social-icon src=https://kelvinkirima.com/github.svg> </a><a href=https://www.linkedin.com/in/kelvin-kirima-25b010184/ target=_blank> <img alt=LinkedIn class=social-icon src=https://kelvinkirima.com/linkedin.svg> </a><a href=https://twitter.com/014kirima target=_blank> <img alt=Twitter class=social-icon src=https://kelvinkirima.com/twitter.svg> </a></div></div></footer></div>